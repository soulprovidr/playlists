# Playlists Application Rules

## Architecture Overview

This application is a playlist automation tool that:
1. Aggregates music recommendations from various sources (Reddit, RSS feeds)
2. Uses OpenAI to extract artist/track information from text content
3. Builds and maintains Spotify playlists automatically

### Components
- **Server**: Hono-based API server with cron scheduling (entrypoint: `src/_app.ts`)
- **CLI**: Command-line interface for manual operations (entrypoint: `src/_cli.ts`)
- **Config**: YAML-based playlist configuration (`config.yml`)

### Development Environment
- Server runs on port 3000 (start: `npm run start`)
- CLI runs with: `npm run cli`

## Environment Management

### Using mise
- All environment configuration is managed through **mise** (`mise.toml`)
- **NEVER** create or modify `.env` files directly
- **ALWAYS** use `mise set` or edit `mise.toml` to change environment variables
- Environment variables are validated using Zod schema in `src/_env.ts`
- Access environment variables through the `@env` import: `import { env } from "@env"`

### Environment Variables
Current environment variables (defined in `mise.toml`):
- `NODE_ENV`: Environment mode (development/production)
- `HOST`: Server host URL
- `PORT`: Server port number
- `DATABASE_PATH`: Path to SQLite database
- `OPENAI_API_KEY`: OpenAI API key for text extraction
- `SPOTIFY_CLIENT_ID`, `SPOTIFY_CLIENT_SECRET`, `SPOTIFY_REDIRECT_URI`: Spotify OAuth credentials

## Configuration Management

### YAML Configuration (`config.yml`)
The application uses a YAML configuration file for playlist definitions:
- Loaded via `@config` import (`src/_config.ts`)
- Defines `spotifyUserId` and `playlists` array
- Each playlist has: `name`, `spotifyPlaylistId`, `entityType`, and `sources`
- Sources are grouped by type: `reddit` (subreddit names) and `rss` (feed URLs)

### Config Types
- `AppConfig`: Root configuration structure
- `ConfigPlaylist`: Individual playlist configuration
- `ConfigPlaylistSources`: Grouped sources (reddit/rss arrays)
- `ConfigPlaylistSource`: Flattened source with type information

## Database Management

### Using Kysely
- Database interactions are managed through **Kysely** ORM
- **NEVER** use raw SQL queries or other database libraries
- **ALWAYS** use the Kysely query builder interface
- Database instance: Import from `@database`
- Configuration: `kysely.config.ts`

### Database Structure
- SQLite database using `better-sqlite3`
- Database file: `src/database/local.db`
- Tables defined as TypeScript types in respective module folders
- Database schema exported from `src/_database.ts`

### Database Operations

#### Queries
Example query patterns:

    import { database } from "@database";

    // SELECT
    const configs = await database.selectFrom("playlist_configs").selectAll().execute();

    // WHERE
    const config = await database
      .selectFrom("playlist_configs")
      .where("id", "=", configId)
      .selectAll()
      .executeTakeFirst();

#### Migrations
- Location: `src/database/migrations/`
- Create new migration: `npm run migrate:make -- migration_name`
- Run migrations: `npm run migrate:latest`
- Clean database: `npm run migrate:clean`

## Logging

### Using the Logger
- All logging is handled by **pino** (via `@logger`)
- **NEVER** use `console.log`, `console.error`, etc. in server code
- **ALWAYS** use the logger from `@logger`

### Logger Usage
Example logging patterns:

    import { logger } from "@logger";

    // Info logging
    logger.info("User logged in");
    logger.info(`Processing ${count} items`);

    // Error logging with error object
    try {
      // some code
    } catch (error) {
      logger.error({ err: error }, "Failed to process request");
    }

    // Debug logging
    logger.debug("Detailed debug information");

    // Warning logging
    logger.warn("Something unexpected happened");

### Log Levels
- `trace`: Most verbose, fine-grained information
- `debug`: Debug information (development only)
- `info`: Informational messages
- `warn`: Warning messages
- `error`: Error messages
- `fatal`: Fatal errors

## Code Organization

### Path Aliases
Use the following path aliases (defined in `tsconfig.json`):
- `@config` → `src/_config`
- `@database` → `src/_database`
- `@database/*` → `src/database/*`
- `@env` → `src/_env`
- `@jobs` → `src/_jobs`
- `@lib/*` → `src/lib/*`
- `@logger` → `src/_logger`
- `@modules/*` → `src/modules/*`
- `@tasks/*` → `src/tasks/*`

**ALWAYS** use path aliases instead of relative imports for these directories.

### Project Structure

    src/
    ├── _app.ts           # Server entrypoint
    ├── _cli.ts           # CLI entrypoint
    ├── _config.ts        # YAML config loader
    ├── _database.ts      # Database instance
    ├── _env.ts           # Environment validation
    ├── _jobs.ts          # Job queue instance
    ├── _logger.ts        # Logger instance
    ├── app/              # App routes and services
    ├── database/         # Migrations and database tasks
    ├── lib/              # Shared utilities
    ├── modules/          # Feature modules
    └── tasks/            # Background tasks

### Module Structure
Modules follow a consistent pattern in `src/modules/`:

    src/modules/[module-name]/
    ├── [module-name].types.ts    # TypeScript types and interfaces
    ├── [module-name].repo.ts     # Database repository layer (Kysely queries)
    ├── [module-name].service.ts  # Business logic layer
    └── [module-name].helpers.ts  # Module helpers (optional)

### Current Modules
- `open-ai/`: OpenAI API integration for text extraction
- `playlist-configs/`: Playlist configuration management
- `playlist-items/`: Playlist item validation and types
- `playlist-sources/`: Source management (Reddit, RSS submodules)
- `spotify/`: Spotify API integration and access token management

### Layered Architecture
1. **Routes Layer** (`*.routes.ts`): Handle HTTP requests/responses
2. **Service Layer** (`*.service.ts`): Business logic and orchestration
3. **Repository Layer** (`*.repo.ts`): Database access through Kysely
4. **Helpers Layer** (`*.helpers.ts`): Module helpers
5. **Types Layer** (`*.types.ts`): TypeScript interfaces and types

**NEVER** call repository functions directly from routes. Always go through the service layer.

When importing services, repositories, and helpers, use the following pattern:

    import * as moduleService from "./[module-name].service";
    import * as moduleRepo from "./[module-name].repo";
    import * as moduleHelpers from "./[module-name].helpers";

### Tasks
Background tasks are located in `src/tasks/`:
- `build-playlist.ts`: Builds a playlist from configured sources
- `schedule-playlists.ts`: Schedules playlists for building based on cadence
- `seed-playlists.ts`: Seeds database from `config.yml` on startup

## Server Architecture (Hono)

### Server Setup
- Framework: Hono
- Entry point: `src/_app.ts`
- Middleware: request logging, secure headers, context storage
- Cron scheduling with `node-cron` for hourly playlist checks

### Routing
Example route pattern:

    import { Hono } from "hono";

    const routes = new Hono()
      .get("/endpoint", async (c) => {
        // Handle GET request
        return c.json({ data: "response" });
      })
      .post("/endpoint", async (c) => {
        // Handle POST request
        return c.json({ data: "response" });
      });

### Authentication
- Spotify OAuth flow at `/authorize` and `/authorize/callback`
- Access tokens stored in database via `spotify-access-tokens` module

## Job Queue

### Using the Job Queue
- Job queue instance available via `@jobs` import
- Used for background processing of playlist builds
- Processes jobs sequentially with error handling

### Job Queue Usage
Example:

    import { jobs } from "@jobs";

    jobs.add(
      async () => {
        await buildPlaylist(playlistConfigId);
      },
      {
        onSuccess: (jobId) => logger.info(`Job ${jobId} completed`),
        onError: (jobId, error) => logger.error({ err: error }, `Job ${jobId} failed`),
      }
    );

## CLI Interface

### CLI Usage
- Entry point: `src/_cli.ts`
- Run with: `npm run cli`
- Uses `@inquirer/prompts` for interactive prompts

### Available Commands
- **Rebuild a playlist**: Select and rebuild a specific playlist
- **Schedule playlists**: Run the playlist scheduling task

### CLI Best Practices
- Use interactive prompts for user input
- Provide clear error messages
- Handle exit signals gracefully

## Best Practices

### TypeScript
- Use strict type checking
- Define interfaces in `*.types.ts` files
- Export types from module index when shared

### Error Handling
- Use try-catch blocks for async operations
- Use `exponential-backoff` for retrying API calls
- Log errors appropriately with error objects
- Update build status on playlist build failures

### Code Style
- Use Prettier for formatting (`.prettierrc.json`)
- Follow ESLint rules (`eslint.config.mjs`)
- Use async/await over promises
- Prefer named exports over default exports

### Dependencies
- Use lodash for utility functions (chaining, shuffle, chunk)
- Use @js-joda for date/time operations
- Use axios for HTTP requests
- Use zod for validation
- Never install raw SQL libraries
- Never install additional environment management libraries (use mise)